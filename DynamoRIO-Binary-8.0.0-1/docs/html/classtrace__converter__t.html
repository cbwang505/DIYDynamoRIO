<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO API: trace_converter_t&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classtrace__converter__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">trace_converter_t&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;raw2trace.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae253fcb481b01fb3cca4cbd35cd1945d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#ae253fcb481b01fb3cca4cbd35cd1945d">trace_converter_t</a> (void *dcontext)</td></tr>
<tr class="separator:ae253fcb481b01fb3cca4cbd35cd1945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2653cfc313a65413e4f7a3fe467e237e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a2653cfc313a65413e4f7a3fe467e237e">~trace_converter_t</a> ()</td></tr>
<tr class="separator:a2653cfc313a65413e4f7a3fe467e237e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba9855ba99747cb999afcf409bbab82"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#adba9855ba99747cb999afcf409bbab82">process_offline_entry</a> (void *tls, const offline_entry_t *in_entry, thread_id_t tid, OUT bool *end_of_record, OUT bool *last_bb_handled)</td></tr>
<tr class="separator:adba9855ba99747cb999afcf409bbab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534c6ae391de423b84fe04c58768a9c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a534c6ae391de423b84fe04c58768a9c4">read_header</a> (void *tls, OUT <a class="el" href="structtrace__header__t.html">trace_header_t</a> *header)</td></tr>
<tr class="separator:a534c6ae391de423b84fe04c58768a9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044751e676c6c540cde16fde06ade635"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; module_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a044751e676c6c540cde16fde06ade635">modvec_</a> () const</td></tr>
<tr class="separator:a044751e676c6c540cde16fde06ade635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c0777af8fa9ead53cb8aa6cadadee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a89c0777af8fa9ead53cb8aa6cadadee0">set_modvec_</a> (const std::vector&lt; module_t &gt; *modvec)</td></tr>
<tr class="separator:a89c0777af8fa9ead53cb8aa6cadadee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2ef4634f6b052a10b0836724405826e0"><td class="memItemLeft" align="right" valign="top">void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a2ef4634f6b052a10b0836724405826e0">dcontext_</a></td></tr>
<tr class="separator:a2ef4634f6b052a10b0836724405826e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669037d643da10b6aa22f16e851b2944"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a669037d643da10b6aa22f16e851b2944">passed_dcontext_</a> = false</td></tr>
<tr class="separator:a669037d643da10b6aa22f16e851b2944"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a1bd6b969039316a9c1369d52b15f9c62"><td class="memItemLeft" align="right" valign="top">static const uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a1bd6b969039316a9c1369d52b15f9c62">WRITE_BUFFER_SIZE</a> = 64</td></tr>
<tr class="separator:a1bd6b969039316a9c1369d52b15f9c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class trace_converter_t&lt; T &gt;</h3>

<p><a class="el" href="classtrace__converter__t.html">trace_converter_t</a> is a reusable component that encapsulates raw trace conversion.</p>
<p>Conversion happens from a data source abstracted by the type parameter T. We make no assumption about how thread buffers are organized. We do assume the internal composition of thread buffers is "as written" by the thread. For example, all thread buffers belonging to different threads may be in a separate files; or buffers may be co-located in one large file, or spread accross multiple, mixed-thread files.</p>
<p><a class="el" href="classtrace__converter__t.html">trace_converter_t</a> expects to be instantiated with its type template T which should provide the following APIs. These pass through an opaque pointer which provides per-traced-thread-local data to the converter:</p>
<ul>
<li>
<p class="startli">const offline_entry_t *get_next_entry(void *tls)</p>
<p class="interli">Point to the next offline entry_t. There is no assumption about the underlying source of the data, and <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> will not attempt to dereference past the provided pointer.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">void unread_last_entry(void *tls)</p>
<p class="interli">Ensure that the next call to get_next_entry() re-reads the last value.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">trace_entry_t *get_write_buffer(void *tls)</p>
<p class="interli">Return a writable buffer guaranteed to be at least <a class="el" href="classtrace__converter__t.html#a1bd6b969039316a9c1369d52b15f9c62">WRITE_BUFFER_SIZE</a> large. get_write_buffer() may reuse the same buffer after write() or write_delayed_branches() is called.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">bool write(void *tls, const trace_entry_t *start, const trace_entry_t *end)</p>
<p class="interli">Writes the converted traces between start and end, where end is past the last item to write. Both start and end are assumed to be pointers inside a buffer returned by get_write_buffer().</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">std::string write_delayed_branches(const trace_entry_t *start, const trace_entry_t *end)</p>
<p class="interli">Similar to write(), but treat the provided traces as delayed branches: if they are the last values in a record, they belong to the next record of the same thread.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">std::string on_thread_end(void *tls)</p>
<p class="interli">Callback notifying the currently-processed thread has exited. <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> extenders are expected to track record metadata themselves. <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> offers APIs for extracting that metadata.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">void log(uint level, const char *fmt, ...)</p>
<p class="interli">Implementers are given the opportunity to implement their own logging. The level parameter represents severity: the lower the level, the higher the severity.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">void log_instruction(uint level, app_pc decode_pc, app_pc orig_pc);</p>
<p class="interli">Similar to log() but this disassembles the given PC.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">void add_to_statistic(void *tls, raw2trace_statistic_t stat, int value)</p>
<p class="interli">Increases the per-thread counter for the statistic identified by stat by value. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">bool raw2trace_t::instr_summary_exists(void *tls, uint64 modidx, uint64 modoffs, app_pc block_start_pc, app_pc pc) const</p>
<p class="interli">Returns whether an <a class="el" href="structinstr__summary__t.html">instr_summary_t</a> representation of the instruction at pc inside the block that begins at block_start_pc in the specified module exists. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">const <a class="el" href="structinstr__summary__t.html">instr_summary_t</a> *get_instr_summary(void *tls, uint64 modidx, uint64 modoffs, app_pc block_start_pc, int instr_count, int index, INOUT app_pc *pc, app_pc orig)</p>
<p class="interli">Return the <a class="el" href="structinstr__summary__t.html">instr_summary_t</a> representation of the index-th instruction (at *pc) inside the block that begins at block_start_pc and contains instr_count instructions in the specified module. Updates the value at pc to the PC of the next instruction. It is assumed the app binaries have already been loaded using <a class="el" href="classmodule__mapper__t.html">module_mapper_t</a>, and the values at *pc point within memory mapped by the module mapper. This API provides an opportunity to cache decoded instructions. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">bool set_instr_summary_flags(void *tls, uint64 modidx, uint64 modoffs, app_pc block_start_pc, int instr_count, int index, app_pc pc, app_pc orig, bool write, int memop_index, bool use_remembered_base, bool remember_base)</p>
<p class="interli">Sets two flags stored in the memref_summary_t inside the <a class="el" href="structinstr__summary__t.html">instr_summary_t</a> for the index-th instruction (at pc) inside the block that begins at block_start_pc and contains instr_count instructions in the specified module. The flags use_remembered_base and remember_base are set for the source (write==false) or destination (write==true) operand of index memop_index. The flags are OR-ed in: i.e., they are never cleared. </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">void set_prev_instr_rep_string(void *tls, bool value)</p>
<p class="interli">Sets a per-traced-thread cached flag that is read by was_prev_instr_rep_string(). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">bool was_prev_instr_rep_string(void *tls)</p>
<p class="interli">Queries a per-traced-thread cached flag that is set by set_prev_instr_rep_string(). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">int get_version(void *tls)</p>
<p class="interli">Returns the trace file version (an OFFLINE_FILE_VERSION* constant). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">offline_file_type_t get_file_type(void *tls)</p>
<p class="endli">Returns the trace file type (a combination of OFFLINE_FILE_TYPE* constants).  </p>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae253fcb481b01fb3cca4cbd35cd1945d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae253fcb481b01fb3cca4cbd35cd1945d">&#9670;&nbsp;</a></span>trace_converter_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::<a class="el" href="classtrace__converter__t.html">trace_converter_t</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a new <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> object. If a nullptr dcontext is passed, creates a new DR context va <a class="el" href="dr__tools_8h.html#af63184f56cc0508e2840f64e84b1c48d">dr_standalone_init()</a>. </p>

</div>
</div>
<a id="a2653cfc313a65413e4f7a3fe467e237e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2653cfc313a65413e4f7a3fe467e237e">&#9670;&nbsp;</a></span>~trace_converter_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::~<a class="el" href="classtrace__converter__t.html">trace_converter_t</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys this <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> object. If a nullptr dcontext_in was passed to the constructor, calls <a class="el" href="dr__tools_8h.html#afd5830692c2e72aa3e7de3febc794b0a">dr_standalone_exit()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a044751e676c6c540cde16fde06ade635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044751e676c6c540cde16fde06ade635">&#9670;&nbsp;</a></span>modvec_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;module_t&gt;&amp; <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::modvec_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the module map. </p>

</div>
</div>
<a id="adba9855ba99747cb999afcf409bbab82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba9855ba99747cb999afcf409bbab82">&#9670;&nbsp;</a></span>process_offline_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::process_offline_entry </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const offline_entry_t *&#160;</td>
          <td class="paramname"><em>in_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_id_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>end_of_record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>last_bb_handled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert starting from in_entry, and reading more entries as required. Sets end_of_record to true if processing hit the end of a record. <a class="el" href="classtrace__converter__t.html#a89c0777af8fa9ead53cb8aa6cadadee0">set_modvec_()</a> must have been called by the implementation before calling this API. </p>

</div>
</div>
<a id="a534c6ae391de423b84fe04c58768a9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534c6ae391de423b84fe04c58768a9c4">&#9670;&nbsp;</a></span>read_header()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::read_header </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="structtrace__header__t.html">trace_header_t</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the header of a thread, by calling T's get_next_entry() successively to populate the header values. The timestamp field is populated only for legacy traces. </p>

</div>
</div>
<a id="a89c0777af8fa9ead53cb8aa6cadadee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c0777af8fa9ead53cb8aa6cadadee0">&#9670;&nbsp;</a></span>set_modvec_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::set_modvec_ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; module_t &gt; *&#160;</td>
          <td class="paramname"><em>modvec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the module map. Must be called before <a class="el" href="classtrace__converter__t.html#adba9855ba99747cb999afcf409bbab82">process_offline_entry()</a> is called. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a2ef4634f6b052a10b0836724405826e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef4634f6b052a10b0836724405826e0">&#9670;&nbsp;</a></span>dcontext_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* const <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::dcontext_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pointer to the DR context. </p>

</div>
</div>
<a id="a669037d643da10b6aa22f16e851b2944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669037d643da10b6aa22f16e851b2944">&#9670;&nbsp;</a></span>passed_dcontext_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::passed_dcontext_ = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether a non-nullptr dcontext was passed to the constructor. </p>

</div>
</div>
<a id="a1bd6b969039316a9c1369d52b15f9c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd6b969039316a9c1369d52b15f9c62">&#9670;&nbsp;</a></span>WRITE_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::WRITE_BUFFER_SIZE = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The trace_entry_t buffer returned by get_write_buffer() is assumed to be at least <a class="el" href="classtrace__converter__t.html#a1bd6b969039316a9c1369d52b15f9c62">WRITE_BUFFER_SIZE</a> large. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drmemtrace/<a class="el" href="raw2trace_8h.html">raw2trace.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classtrace__converter__t.html">trace_converter_t</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO API version 8.0.0 --- Wed Apr 22 2020 00:42:08 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
